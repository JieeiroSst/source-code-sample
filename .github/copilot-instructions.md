<!-- Autogenerated guidance for AI coding agents working in this repository -->
# Copilot / AI agent instructions — hexagon-app

Be concise and act like a helpful Go engineer familiar with Hexagonal/Clean Architecture and Uber FX. Focus on actionable, repo-specific facts the next contributor (human or AI) needs to be productive.

Key facts
- Language: Go (module root contains `go.mod`).
- Architecture: Hexagon (Ports & Adapters). See `internal/core`, `internal/ports`, and `internal/adapters` for domain, interfaces, and implementations.
- Dependency injection: Uber FX.

What to read first (order matters)
1. `README.md` — high-level overview, run/dev notes and docker compose.
2. `cmd/api/main.go` — application entry, FX app wiring and lifecycle.
3. `fx/module.go` and `fx/lifecycle.go` — how DI modules and hooks are registered.
4. `internal/core/domain` — domain models and domain errors (`errors.go`, `user.go`).
5. `internal/ports` — contracts the core expects (`service.go`, `repository.go`, `cache.go`, `publisher.go`).
6. `internal/adapters` — concrete implementations (HTTP handlers, RabbitMQ consumer/publisher, Redis cache, Postgres repository).

Important patterns and examples (be specific)
- Ports & Adapters: Business logic lives in `internal/core` and talks to infrastructure only via interfaces in `internal/ports`. Implementations live under `internal/adapters`.
  - Example: `internal/ports/repository.go` defines repository contract; `internal/adapters/repository/postgres` contains Postgres implementation.
- FX modules: The app constructs dependencies with Uber FX. Look at `fx/module.go` to see which providers and invocations are wired into the application lifecycle.
  - Example: `cmd/api/main.go` boots an `fx.App` — prefer adding constructors/providers there rather than manual global state.
- HTTP handlers: `internal/adapters/http/handlers` contain request handling and map to core services. Follow existing handler signatures and use the provided middleware in `internal/adapters/http/middleware` (`auth.go`, `rate_limiter.go`, `security.go`).
- Message flow (RabbitMQ): `internal/adapters/consumer/rabbitmq` and `internal/adapters/publisher/rabbitmq` implement messaging. Consumers use ack/nack/requeue with a retry+dead-letter strategy; replicate the pattern when adding new consumers.
- Caching: `internal/adapters/cache/redis/cache.go` follows cache-aside — always check cache then fallback to repository and repopulate cache.
- Security: JWT, bcrypt and AES utilities live in `pkg/security` (`jwt.go`, `crypto.go`). Use these helpers for token creation/validation and encryption.

Build / run / debug
- Install deps: `go mod download`.
- Run locally: `go run cmd/api/main.go` (the README shows env and DB setup). The app is an fx application — run in foreground for logs.
- Tests: run `go test ./...` from repo root.
- Docker: `docker-compose up -d` will start Postgres, Redis and RabbitMQ per `docker-compose.yml`.

Project conventions (non-obvious)
- No global state: prefer constructor injection via FX providers. Do not add package-level singletons unless provided by FX wiring.
- Error handling: domain errors are defined in `internal/core/domain/errors.go`. Use those typed errors when mapping failure modes between layers.
- Logging: use the repo logger package (`pkg/logger`) for structured logs; avoid fmt.Print for server logs.
- Naming: keep adapters under `internal/adapters/<type>/<impl>` (e.g., `http/`, `rabbitmq/`, `redis/`, `postgres/`). Services live under `internal/services` and implement port interfaces.

Integration & external dependencies
- Postgres: repository implementations assume a SQL DB. Check `internal/adapters/repository/postgres` for SQL usage and migrations (if present elsewhere).
- Redis: used for caching in `internal/adapters/cache/redis`.
- RabbitMQ: publisher/consumer patterns in `internal/adapters/publisher/rabbitmq` and `internal/adapters/consumer/rabbitmq`.
- Env config: `infrastructure/config/config.go` reads environment — check `.env.example` and README for required variables.

When editing code
- Keep DI changes in `fx/module.go` or add new fx providers; avoid scattering manual app wiring across `main.go`.
- If adding new adapters, create matching interface in `internal/ports` first, then implement under `internal/adapters` and register provider in fx module.
- For new HTTP endpoints: add handler in `internal/adapters/http/handlers`, register routes in the existing router setup, and reuse middleware from `internal/adapters/http/middleware`.

What not to change without discussion
- Core domain types and port interfaces — changing these impacts many components.
- fx module structure — keep additions additive and register constructors via fx.

If uncertain, show diffs and reference these files in your PR description: `cmd/api/main.go`, `fx/module.go`, `internal/core`, `internal/ports`, `internal/adapters`.

Feedback
If anything here is unclear or missing (I may have missed a small infra file), tell me which area you'd like expanded and I will iterate.
